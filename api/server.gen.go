// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Execute a Blockless Function
	// (POST /api/v1/functions/execute)
	ExecuteFunction(ctx echo.Context) error
	// Install a Blockless Function
	// (POST /api/v1/functions/install)
	InstallFunction(ctx echo.Context) error
	// Get the result of an Execution Request
	// (POST /api/v1/functions/requests/result)
	ExecutionResult(ctx echo.Context) error
	// Check Node health
	// (GET /api/v1/health)
	Health(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// ExecuteFunction converts echo context to params.
func (w *ServerInterfaceWrapper) ExecuteFunction(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ExecuteFunction(ctx)
	return err
}

// InstallFunction converts echo context to params.
func (w *ServerInterfaceWrapper) InstallFunction(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InstallFunction(ctx)
	return err
}

// ExecutionResult converts echo context to params.
func (w *ServerInterfaceWrapper) ExecutionResult(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ExecutionResult(ctx)
	return err
}

// Health converts echo context to params.
func (w *ServerInterfaceWrapper) Health(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Health(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/api/v1/functions/execute", wrapper.ExecuteFunction)
	router.POST(baseURL+"/api/v1/functions/install", wrapper.InstallFunction)
	router.POST(baseURL+"/api/v1/functions/requests/result", wrapper.ExecutionResult)
	router.GET(baseURL+"/api/v1/health", wrapper.Health)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
