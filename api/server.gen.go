// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Execute a Bless Function
	// (POST /api/v1/functions/execute)
	ExecuteFunction(ctx echo.Context) error
	// Execute a Bless Function with a batch of arguments
	// (POST /api/v1/functions/execute/batch)
	ExecuteFunctionBatch(ctx echo.Context) error
	// Install a Bless Function
	// (POST /api/v1/functions/install)
	InstallFunction(ctx echo.Context) error
	// Get the result of an Execution Request
	// (POST /api/v1/functions/requests/result)
	ExecutionResult(ctx echo.Context) error
	// Check Node health
	// (GET /api/v1/health)
	Health(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// ExecuteFunction converts echo context to params.
func (w *ServerInterfaceWrapper) ExecuteFunction(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ExecuteFunction(ctx)
	return err
}

// ExecuteFunctionBatch converts echo context to params.
func (w *ServerInterfaceWrapper) ExecuteFunctionBatch(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ExecuteFunctionBatch(ctx)
	return err
}

// InstallFunction converts echo context to params.
func (w *ServerInterfaceWrapper) InstallFunction(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InstallFunction(ctx)
	return err
}

// ExecutionResult converts echo context to params.
func (w *ServerInterfaceWrapper) ExecutionResult(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ExecutionResult(ctx)
	return err
}

// Health converts echo context to params.
func (w *ServerInterfaceWrapper) Health(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Health(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/api/v1/functions/execute", wrapper.ExecuteFunction)
	router.POST(baseURL+"/api/v1/functions/execute/batch", wrapper.ExecuteFunctionBatch)
	router.POST(baseURL+"/api/v1/functions/install", wrapper.InstallFunction)
	router.POST(baseURL+"/api/v1/functions/requests/result", wrapper.ExecutionResult)
	router.GET(baseURL+"/api/v1/health", wrapper.Health)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
