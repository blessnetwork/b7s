// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Execute a Bless Function
	// (POST /api/v1/functions/execute)
	ExecuteFunction(ctx echo.Context) error
	// Execute a Bless Function with a batch of arguments
	// (POST /api/v1/functions/execute/batch)
	ExecuteFunctionBatch(ctx echo.Context) error
	// Install a Bless Function
	// (POST /api/v1/functions/install)
	InstallFunction(ctx echo.Context) error
	// Get the result of an Execution Request
	// (POST /api/v1/functions/requests/result)
	ExecutionResult(ctx echo.Context) error
	// Check Node health
	// (GET /api/v1/health)
	Health(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// ExecuteFunction converts echo context to params.
func (w *ServerInterfaceWrapper) ExecuteFunction(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ExecuteFunction(ctx)
	return err
}

// ExecuteFunctionBatch converts echo context to params.
func (w *ServerInterfaceWrapper) ExecuteFunctionBatch(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ExecuteFunctionBatch(ctx)
	return err
}

// InstallFunction converts echo context to params.
func (w *ServerInterfaceWrapper) InstallFunction(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InstallFunction(ctx)
	return err
}

// ExecutionResult converts echo context to params.
func (w *ServerInterfaceWrapper) ExecutionResult(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ExecutionResult(ctx)
	return err
}

// Health converts echo context to params.
func (w *ServerInterfaceWrapper) Health(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Health(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/api/v1/functions/execute", wrapper.ExecuteFunction)
	router.POST(baseURL+"/api/v1/functions/execute/batch", wrapper.ExecuteFunctionBatch)
	router.POST(baseURL+"/api/v1/functions/install", wrapper.InstallFunction)
	router.POST(baseURL+"/api/v1/functions/requests/result", wrapper.ExecutionResult)
	router.GET(baseURL+"/api/v1/health", wrapper.Health)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
