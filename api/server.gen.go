// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Execute a Bless Function
	// (POST /api/v1/functions/execute)
	ExecuteFunction(ctx echo.Context) error
	// Execute a Bless Function with a batch of arguments
	// (POST /api/v1/functions/execute/batch)
	ExecuteFunctionBatch(ctx echo.Context) error
	// Install a Bless Function
	// (POST /api/v1/functions/install)
	InstallFunction(ctx echo.Context) error
	// Get the result of an Execution Request
	// (POST /api/v1/functions/requests/result)
	ExecutionResult(ctx echo.Context) error
	// Check Node health
	// (GET /api/v1/health)
	Health(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// ExecuteFunction converts echo context to params.
func (w *ServerInterfaceWrapper) ExecuteFunction(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ExecuteFunction(ctx)
	return err
}

// ExecuteFunctionBatch converts echo context to params.
func (w *ServerInterfaceWrapper) ExecuteFunctionBatch(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ExecuteFunctionBatch(ctx)
	return err
}

// InstallFunction converts echo context to params.
func (w *ServerInterfaceWrapper) InstallFunction(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InstallFunction(ctx)
	return err
}

// ExecutionResult converts echo context to params.
func (w *ServerInterfaceWrapper) ExecutionResult(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ExecutionResult(ctx)
	return err
}

// Health converts echo context to params.
func (w *ServerInterfaceWrapper) Health(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Health(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/api/v1/functions/execute", wrapper.ExecuteFunction)
	router.POST(baseURL+"/api/v1/functions/execute/batch", wrapper.ExecuteFunctionBatch)
	router.POST(baseURL+"/api/v1/functions/install", wrapper.InstallFunction)
	router.POST(baseURL+"/api/v1/functions/requests/result", wrapper.ExecutionResult)
	router.GET(baseURL+"/api/v1/health", wrapper.Health)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
