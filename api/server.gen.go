// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Execute a Blockless Function
	// (POST /api/v1/functions/execute)
	ExecuteFunction(ctx echo.Context) error
	// Install a Blockless Function
	// (POST /api/v1/functions/install)
	InstallFunction(ctx echo.Context) error
	// Get the result of an Execution Request
	// (POST /api/v1/functions/requests/result)
	ExecutionResult(ctx echo.Context) error
	// Check Node health
	// (GET /api/v1/health)
	Health(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// ExecuteFunction converts echo context to params.
func (w *ServerInterfaceWrapper) ExecuteFunction(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ExecuteFunction(ctx)
	return err
}

// InstallFunction converts echo context to params.
func (w *ServerInterfaceWrapper) InstallFunction(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InstallFunction(ctx)
	return err
}

// ExecutionResult converts echo context to params.
func (w *ServerInterfaceWrapper) ExecutionResult(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ExecutionResult(ctx)
	return err
}

// Health converts echo context to params.
func (w *ServerInterfaceWrapper) Health(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Health(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/api/v1/functions/execute", wrapper.ExecuteFunction)
	router.POST(baseURL+"/api/v1/functions/install", wrapper.InstallFunction)
	router.POST(baseURL+"/api/v1/functions/requests/result", wrapper.ExecutionResult)
	router.GET(baseURL+"/api/v1/health", wrapper.Health)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
